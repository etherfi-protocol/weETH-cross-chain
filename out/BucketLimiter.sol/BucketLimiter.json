{"abi":[],"bytecode":{"object":"0x60556032600b8282823980515f1a607314602657634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f80fdfea2646970667358221220167a9e5ff94d6735266a236c55019a19b8d3459242356833ce58fcafb974ea0064736f6c63430008140033","sourceMap":"1717:4085:147:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;1717:4085:147;;;;;;;;;;;;;;;;;","linkReferences":{}},"deployedBytecode":{"object":"0x730000000000000000000000000000000000000000301460806040525f80fdfea2646970667358221220167a9e5ff94d6735266a236c55019a19b8d3459242356833ce58fcafb974ea0064736f6c63430008140033","sourceMap":"1717:4085:147:-:0;;;;;;;;","linkReferences":{}},"methodIdentifiers":{},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"The BucketLimiter contract is used to limit the rate of some action.  Buckets refill at a constant rate, and have a maximum capacity. Each time the consume function is called, the bucket gets depleted by the provided amount. If the bucket is empty, the consume function will return false and the bucket will not be depleted. Rates are measured in units per  second.  To limit storage usage to a single slot, the Bucket struct is packed into a single word, meaning all fields are uint64. Examples: ```sol BucketLimiter.Limit storage limit = BucketLimiter.create(100, 1); limit.consume(10); // returns true, remaining = 90 limit.consume(80); // returns true, remaining = 10 limit.consume(20); // returns false, remaining = 10 // Wait 10 seconds (10 tokens get refilled) limit.consume(20); // returns true, remaining = 0) // Increase capacity limit.setCapacity(200); // remaining = 0, capacity = 200 // Increase refill rate limit.setRefillRate(2); // remaining = 0, capacity = 200, refillRate = 2 // Wait 10 seconds (20 tokens get refilled) limit.consume(20); // returns true, remaining = 0 ```  Developers should notice that rate-limits are vulnerable to two attacks: 1. Sybil-attacks: Rate limits should typically be global across all user       accounts, otherwise an attacker can simply create many accounts to       bypass the rate limit. 2. DoS attacks: Rate limits should typically apply to actions with a       friction such as a fee or a minimum stake time. Otherwise, an       attacker can simply spam the action to deplete the rate limit.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"utils/BucketLimiter.sol\":\"BucketLimiter\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@layerzerolabs/lz-evm-messagelib-v2/contracts/=node_modules/@layerzerolabs/lz-evm-messagelib-v2/contracts/\",\":@layerzerolabs/lz-evm-oapp-v2/contracts-upgradeable/=node_modules/layerzero-v2/oapp/contracts/\",\":@layerzerolabs/lz-evm-oapp-v2/contracts/=node_modules/@layerzerolabs/lz-evm-oapp-v2/contracts/\",\":@layerzerolabs/lz-evm-protocol-v2/contracts/=node_modules/@layerzerolabs/lz-evm-protocol-v2/contracts/\",\":@openzeppelin/=node_modules/@openzeppelin/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":forge-std/=lib/forge-std/src/\",\":layerzero-v2/=node_modules/layerzero-v2/\",\":solidity-bytes-utils/=node_modules/solidity-bytes-utils/\"]},\"sources\":{\"utils/BucketLimiter.sol\":{\"keccak256\":\"0x26dac091185de05a899f25a1612e930ea87570a2c02db6de261e91295dfd2351\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://60a9f4a04a1110b792193eebfbde6cc9d88f964c0e44b3b2392b3943e6b6b13a\",\"dweb:/ipfs/QmQvhqHSX4iwJwEf9dvNVVeKdKCdntAhL5VvJ5GwefGPy2\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.20+commit.a1b79de6"},"language":"Solidity","output":{"abi":[],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@layerzerolabs/lz-evm-messagelib-v2/contracts/=node_modules/@layerzerolabs/lz-evm-messagelib-v2/contracts/","@layerzerolabs/lz-evm-oapp-v2/contracts-upgradeable/=node_modules/layerzero-v2/oapp/contracts/","@layerzerolabs/lz-evm-oapp-v2/contracts/=node_modules/@layerzerolabs/lz-evm-oapp-v2/contracts/","@layerzerolabs/lz-evm-protocol-v2/contracts/=node_modules/@layerzerolabs/lz-evm-protocol-v2/contracts/","@openzeppelin/=node_modules/@openzeppelin/","ds-test/=lib/forge-std/lib/ds-test/src/","forge-std/=lib/forge-std/src/","layerzero-v2/=node_modules/layerzero-v2/","solidity-bytes-utils/=node_modules/solidity-bytes-utils/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"utils/BucketLimiter.sol":"BucketLimiter"},"evmVersion":"shanghai","libraries":{}},"sources":{"utils/BucketLimiter.sol":{"keccak256":"0x26dac091185de05a899f25a1612e930ea87570a2c02db6de261e91295dfd2351","urls":["bzz-raw://60a9f4a04a1110b792193eebfbde6cc9d88f964c0e44b3b2392b3943e6b6b13a","dweb:/ipfs/QmQvhqHSX4iwJwEf9dvNVVeKdKCdntAhL5VvJ5GwefGPy2"],"license":"MIT"}},"version":1},"id":147}